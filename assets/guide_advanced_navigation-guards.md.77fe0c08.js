import{o as n,c as a,a as s}from"./app.9a765ee9.js";const e='{"title":"导航守卫","description":"","frontmatter":{},"headers":[{"level":2,"title":"全局前置守卫","slug":"全局前置守卫"},{"level":2,"title":"全局后置钩子","slug":"全局后置钩子"},{"level":2,"title":"完整的导航解析流程","slug":"完整的导航解析流程"}],"relativePath":"guide/advanced/navigation-guards.md","lastUpdated":1620048614683}',o={},t=s('<h1 id="导航守卫"><a class="header-anchor" href="#导航守卫" aria-hidden="true">#</a> 导航守卫</h1><p>正如其名，microprogram-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。</p><h2 id="全局前置守卫"><a class="header-anchor" href="#全局前置守卫" aria-hidden="true">#</a> 全局前置守卫</h2><p>你可以使用 <code>router.beforeEach</code> 注册一个全局前置守卫：</p><div class="language-js"><pre><code><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token function">createRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n\nrouter<span class="token punctuation">.</span><span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n  <span class="token comment">// 返回 false 以取消导航</span>\n  <span class="token keyword">return</span> <span class="token boolean">false</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div><p>当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于<strong>等待中</strong>。</p><p>每个守卫方法接收两个参数：</p><ul><li><strong><code>to</code></strong>: 即将要进入的目标</li><li><strong><code>from</code></strong>: 当前导航正要离开的路由</li></ul><p>可以返回的值如下:</p><ul><li><code>false</code>: 取消当前的导航。如果浏览器的 URL 改变了(可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 <code>from</code> 路由对应的地址。</li><li>一个路由地址: 通过一个路由地址跳转到一个不同的地址，就像你调用 <code>router.push()</code> 一样，你可以设置诸如 <code>replace: true</code> 或 <code>name: &#39;home&#39;</code> 之类的配置。当前的导航被中断，然后进行一个新的导航，就和 <code>from</code> 一样。</li></ul><p>如果遇到了意料之外的情况，可能会抛出一个 <code>Error</code>。这会取消导航并且调用 <code>router.onError()</code> 注册过的回调。</p><p>如果什么都没有，<code>undefined</code> 或返回 <code>true</code>，<strong>则导航是有效的</strong>，并调用下一个导航守卫</p><p>以上所有都同 <strong><code>async</code> 函数</strong> 和 Promise 工作方式一样：</p><div class="language-js"><pre><code>router<span class="token punctuation">.</span><span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token comment">// canUserAccess() 返回 `true` 或 `false`</span>\n  <span class="token keyword">return</span> <span class="token keyword">await</span> <span class="token function">canUserAccess</span><span class="token punctuation">(</span>to<span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div><h2 id="全局后置钩子"><a class="header-anchor" href="#全局后置钩子" aria-hidden="true">#</a> 全局后置钩子</h2><p>你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 <code>next</code> 函数也不会改变导航本身：</p><div class="language-js"><pre><code>router<span class="token punctuation">.</span><span class="token function">afterEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token function">sendToAnalytics</span><span class="token punctuation">(</span>to<span class="token punctuation">.</span>fullPath<span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div><p>它们对于分析、更改页面标题、声明页面等辅助功能以及许多其他事情都很有用。</p><h2 id="完整的导航解析流程"><a class="header-anchor" href="#完整的导航解析流程" aria-hidden="true">#</a> 完整的导航解析流程</h2><ol><li>导航被触发。</li><li>调用全局的 <code>beforeEach</code> 守卫。</li><li>触发页面跳转。</li><li>调用全局的 <code>afterEach</code> 钩子。</li></ol>',20);o.render=function(s,e,o,p,c,r){return n(),a("div",null,[t])};export default o;export{e as __pageData};
